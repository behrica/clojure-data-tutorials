[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Using ONNX models from clojure",
    "section": "",
    "text": "This is part of the Scicloj Clojure Data Scrapbook.\n\n1 Preface\nONNX is an upcoming exchange format for machine learning models. It is platform indepedent and allows, for example, to train models in python, export the trained model into a file, and then use it in Java / Clojure for inference\n\nsource: projects/ml/onnx/notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "onnx.html",
    "href": "onnx.html",
    "title": "Using ONNX models from clojure",
    "section": "",
    "text": "(ns onnx\n  (:require [tablecloth.api :as tc]\n            [clojure.java.data :as j])\n  (:import [ai.onnxruntime OrtEnvironment OrtSession$SessionOptions\n            OnnxTensor]))\n\nWe assume that we get an ONNX file from somewhere and want to use it from Clojure. ONNX files can for example be trained with Python sklearn and exported to ONNX format. There are as well model zoos existing, which allow to download pre-trained models.\nWe can open such file using the JAVA ONNX run-time with has the maven coordinates com.microsoft.onnxruntime/onnxruntime {:mvn/version “1.19.0”} We use here a model which was trained on the well know iris data and can predict the species\n\n(def env (OrtEnvironment/getEnvironment))\n\n\n(def session (.createSession env \"logreg_iris.onnx\"))\n\nWe can inspect the model and among other things discover which input format it needs.\n\n(j/from-java-deep\n (.getInputInfo session)\n {})\n\n\n{\"float_input\"\n {:info\n  {:dimensionNames (\"\" \"\"),\n   :numElements -4,\n   :scalar false,\n   :shape (-1 4)},\n  :name \"float_input\"}}\n\nThis shows us that it has one input called “float_input” which needs to be a 2D tensor with dimensions (anyNumber, 4) This matches our knowledge on the iris data, which has 4 columns (+ prediction)\nIn a similar way we can introspect the output after inference:\n\n(j/from-java-deep\n (.getOutputInfo session)\n {})\n\n\n{\"output_label\"\n {:info\n  {:dimensionNames (\"\"), :numElements -1, :scalar false, :shape (-1)},\n  :name \"output_label\"},\n \"output_probability\"\n {:info {:sequenceOfMaps true}, :name \"output_probability\"}}\n\nThis outputs one value for each row of the input, which matches as well the iris data. Now we need to construct an instance of ai.onnxruntime.OnnxTensor of shape [-1,4] This can be done starting from a vector-of-vector, for example\n\n(def input-data\n  [[7   0.5  0.5 0.5]\n   [0.5 1    1     1]])\n\n\n(def tensor (OnnxTensor/createTensor\n             env\n             (into-array (map float-array input-data))))\n\n\ntensor\n\n\n#object[ai.onnxruntime.OnnxTensor 0x54c976be \"OnnxTensor(info=TensorInfo(javaType=FLOAT,onnxType=ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT,shape=[2, 4]),closed=false)\"]\n\n\n(def prediction (.run session {\"float_input\" tensor}))\n\n\nprediction\n\n\n#object[ai.onnxruntime.OrtSession$Result 0x5b61e35b \"ai.onnxruntime.OrtSession$Result@5b61e35b\"]\n\nWe have two things in prediction result:\n\n(map key prediction)\n\n\n(\"output_label\" \"output_probability\")\n\nnamely predicted labels and probabilities We need a bit of inter-op to get the numbers out of the prediction predicted species:\n\n(-&gt;  prediction first val .getValue)\n\n\n[0, 0]\n\nprobability distribution for each species for all labels:\n\n(map\n #(.getValue %)\n (-&gt;  prediction second val .getValue))\n\n\n({0 0.6436056, 1 0.35639435, 2 8.642593E-8}\n {0 0.99678445, 1 0.0032155933, 2 4.3943203E-8})\n\nIn case we ave our data to be used in a tech.ml.dataset\n\n(def ds\n  (tc/dataset [[0.5 0.5 0.5 0.5]\n               [1   1   1   1]\n               [1   1   2   7]\n               [3   1   2   1]\n               [7   8   2   10]]))\n\nwe can convert it to a tensor as well easily\n\n(def tensor-2 \n  (OnnxTensor/createTensor \n      env \n     (into-array (map float-array (tc/rows ds)))))\n\nRunning predictions is then te same.\n\n(def prediction-2 (.run session {\"float_input\" tensor-2}))\n\n\n(.. prediction-2 (get 0) getValue)\n\n\n[0, 0, 2, 0, 2]\n\nOverall we an use any ONNX model from Clojure. This allows polyglot scenarios where data preprocession and model evaluation is done in Clojure, while training is done in Python which its huge ecosystem of models.\n\nsource: projects/ml/onnx/notebooks/onnx.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>onnx.html</span>"
    ]
  }
]