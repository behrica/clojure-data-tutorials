[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Clojure Data Scrapbook",
    "section": "",
    "text": "Preface\nThis is the Clojure Data Scrapbook."
  },
  {
    "objectID": "copies_of_projects/main/docs/scicloj/scrapbook/visualization_quarto.html#visualizing-datases-with-hanami",
    "href": "copies_of_projects/main/docs/scicloj/scrapbook/visualization_quarto.html#visualizing-datases-with-hanami",
    "title": "1  Data visualization",
    "section": "1.1 Visualizing datases with Hanami",
    "text": "1.1 Visualizing datases with Hanami\n\n(kind/vega-lite\n (hc/xform ht/point-chart\n           :DATA (-> dataset1\n                     (tc/rows :as-maps)\n                     vec)\n           :MSIZE 200))\n\n\n…"
  },
  {
    "objectID": "copies_of_projects/main/docs/scicloj/scrapbook/visualization_quarto.html#visualizing-datases-with-hanami-using-noj",
    "href": "copies_of_projects/main/docs/scicloj/scrapbook/visualization_quarto.html#visualizing-datases-with-hanami-using-noj",
    "title": "1  Data visualization",
    "section": "1.2 Visualizing datases with Hanami using Noj",
    "text": "1.2 Visualizing datases with Hanami using Noj\n\n(-> dataset1\n    (vis/hanami-plot ht/point-chart\n                     :MSIZE 200))\n\n\n…\n\n\n\n\n\nsource: projects/main/notebooks/scicloj/scrapbook/visualization.clj"
  },
  {
    "objectID": "copies_of_projects/main/docs/scicloj/scrapbook/python_quarto.html#using-python-visualizations",
    "href": "copies_of_projects/main/docs/scicloj/scrapbook/python_quarto.html#using-python-visualizations",
    "title": "2  Python interop",
    "section": "2.1 Using Python visualizations",
    "text": "2.1 Using Python visualizations\n\n(require-python '[numpy :as np]\n                '[numpy.random :as np.random]\n                'matplotlib.pyplot\n                '[seaborn :as sns]\n                'json)\n\n\n:ok\n\n\n(def sine-data\n  (-> {:x (range 0 (* 3 np/pi) 0.1)}\n      tc/dataset\n      (tc/add-column :y #(fun/sin (:x %)))))\n\n\n(vis.python/with-pyplot\n  ;; http://gigasquidsoftware.com/blog/2020/01/18/parens-for-pyplot/\n  (matplotlib.pyplot/plot\n   (:x sine-data)\n   (:y sine-data)))\n\n\n…\n\n\n(vis.python/pyplot\n #(matplotlib.pyplot/plot\n   (:x sine-data)\n   (:y sine-data)))\n\n\n…\n\nhttps://seaborn.pydata.org/tutorial/introduction\n\n(let [tips (sns/load_dataset \"tips\")]\n  (sns/set_theme)\n  (vis.python/pyplot\n   #(sns/relplot :data tips\n                 :x \"total_bill\"\n                 :y \"tip\"\n                 :col \"time\"\n                 :hue \"smoker\"\n                 :style \"smoker\"\n                 :size \"size\")))\n\n\n…\n\n\n\n\n\nsource: projects/main/notebooks/scicloj/scrapbook/python.clj"
  },
  {
    "objectID": "copies_of_projects/main/docs/scicloj/scrapbook/mathbox_quarto.html",
    "href": "copies_of_projects/main/docs/scicloj/scrapbook/mathbox_quarto.html",
    "title": "3  Mathbox.cljs",
    "section": "",
    "text": "source: projects/main/notebooks/scicloj/scrapbook/mathbox.clj\n\n\n\n\n\n(ns scicloj.scrapbook.mathbox\n  (:require [scicloj.kindly.v3.kind :as kind]))\n\ninspired by the official MathBox.cljs tutorial\n\n(kind/hiccup\n '[(let [Data (fn []\n                [mathbox.primitives/Interval\n                 {:expr (fn [emit x _i t]\n                          (emit x (Math/sin (+ x t))))\n                  :width 64\n                  :channels 2}])\n         Curve (fn []\n                 [:<>\n                  [Data]\n                  [mathbox.primitives/Line {:width 5\n                                            :color \"#3090FF\"}]])\n         Main (fn []\n                [mathbox.core/MathBox\n                 {:container {:style {:height \"400px\" :width \"100%\"}}\n                  :focus 3}\n                 [mathbox.primitives/Camera {:position [0 0 3]\n                                             :proxy true}]\n                 [mathbox.primitives/Cartesian\n                  {:range [[-2 2] [-1 1]]\n                   :scale [2 1]}\n                  [mathbox.primitives/Axis {:axis 1 :width 3 :color \"black\"}]\n                  [mathbox.primitives/Axis {:axis 2 :width 3 :color \"black\"}]\n                  [mathbox.primitives/Grid {:width 2 :divideX 20 :divideY 10}]\n                  [Curve]]])\n         *state (r/atom {:open? false})]\n     (fn []\n       [:div\n        [:button {:on-click #(swap! *state update :open? not)}\n         (if (:open? @*state)\n           \"close\"\n           \"open\")]\n        (when (:open? @*state)\n          [Main])]))])\n\n\n…\n\n\n\n\n\nsource: projects/main/notebooks/scicloj/scrapbook/mathbox.clj"
  },
  {
    "objectID": "copies_of_projects/main/docs/scicloj/scrapbook/tests_quarto.html#using-clojure.test-in-a-notebook",
    "href": "copies_of_projects/main/docs/scicloj/scrapbook/tests_quarto.html#using-clojure.test-in-a-notebook",
    "title": "4  Tests",
    "section": "4.1 Using clojure.test in a notebook",
    "text": "4.1 Using clojure.test in a notebook\nStandard Clojure tests may be integrated into notebooks.\n\n(require '[clojure.test :refer [deftest is]])\n\n\nnil\n\nTests returning a boolean value (as they usually do, ending with a check) are rendered displaying that value as a clear x (failure) or v (success) mark:\n\n(def test-dataset\n  (tc/dataset {:x [1 2 3]\n               :y [4 5 6]}))\n\n\n(deftest mytest1\n  (-> test-dataset\n      tc/row-count\n      (= 3)\n      is))\n\n\n\n✓\n\n\nTests returning a non-boolean value are rendered simply displaying that value:\n\n(deftest mytest2\n  (-> test-dataset\n      tc/row-count\n      (= 3)\n      is)\n  test-dataset)\n\n\n…\n\nThe is-> function allows performing a few checks in a pipeline and returning a different value to be displayed:\n\n(deftest mytest3\n  (-> 2\n      (+ 3)\n      (is-> > 4)\n      (* 10)\n      (is-> = 50)\n      (* 10)))\n\n\n500\n\nThese features open the way for literate testing / testable documentation solutions, such as those we have been using in the past (e.g., in tutorials of ClojisR using Notespace v2)."
  },
  {
    "objectID": "copies_of_projects/main/docs/scicloj/scrapbook/tests_quarto.html#example",
    "href": "copies_of_projects/main/docs/scicloj/scrapbook/tests_quarto.html#example",
    "title": "4  Tests",
    "section": "4.2 Example",
    "text": "4.2 Example\nThe following is an adaptation of a little part of the Tablecloth documentation.\nWe started adding calls to dettest and is-> to see how these things feel and how much they do or do not interfere with the reading experience.\nSee the Zulip discussion;\n\n(def DS (tc/dataset {:V1 (take 9 (cycle [1 2]))\n                     :V2 (range 1 10)\n                     :V3 (take 9 (cycle [0.5 1.0 1.5]))\n                     :V4 (take 9 (cycle [\"A\" \"B\" \"C\"]))}))\n\n\n4.2.1 Group-by\nGrouping by is an operation which splits dataset into subdatasets and pack it into new special type of… dataset. I distinguish two types of dataset: regular dataset and grouped dataset. The latter is the result of grouping.\nGrouped dataset is annotated in by :grouped? meta tag and consist following columns:\n\n:name - group name or structure\n:group-id - integer assigned to the group\n:data - groups as datasets\n\nAlmost all functions recognize type of the dataset (grouped or not) and operate accordingly.\nYou can’t apply reshaping or join/concat functions on grouped datasets.\n\n4.2.1.1 Grouping\nGrouping is done by calling group-by function with arguments:\n\nds - dataset\ngrouping-selector - what to use for grouping\noptions:\n:result-type - what to return:\n:as-dataset (default) - return grouped dataset\n:as-indexes - return rows ids (row number from original dataset)\n:as-map - return map with group names as keys and subdataset as values\n:as-seq - return sequens of subdatasets\n:select-keys - list of the columns passed to a grouping selector function\n\nAll subdatasets (groups) have set name as the group name, additionally group-id is in meta.\nGrouping can be done by:\n\nsingle column name\nseq of column names\nmap of keys (group names) and row indexes\nvalue returned by function taking row as map (limited to :select-keys)\n\nNote: currently dataset inside dataset is printed recursively so it renders poorly from markdown. So I will use :as-seq result type to show just group names and groups. List of columns in grouped dataset\n\n(deftest columns-in-grouped-ds\n  (-> DS\n      (tc/group-by :V1)\n      (is-> #(-> % tc/row-count (= 2)))\n      (tc/column-names)\n      (is-> = [:V1 :V2 :V3 :V4])))\n\n\n(:V1 :V2 :V3 :V4)\n\nList of columns in grouped dataset treated as regular dataset\n\n(deftest columns-in-grouped-ds-as-regular-ds-test\n  (-> DS\n      (tc/group-by :V1)\n      (tc/as-regular-dataset)\n      (tc/column-names)\n      (is-> = [:name :group-id :data])))\n\n\n(:name :group-id :data)\n\nContent of the grouped dataset\n\n(tc/columns (tc/group-by DS :V1) :as-map)\n\n\n{:name #tech.v3.dataset.column&lt;int64&gt;[2]\n:name\n[1, 2], :group-id #tech.v3.dataset.column&lt;int64&gt;[2]\n:group-id\n[0, 1], :data #tech.v3.dataset.column&lt;dataset&gt;[2]\n:data\n[Group: 1 [5 4]:\n\n| :V1 | :V2 | :V3 | :V4 |\n|----:|----:|----:|-----|\n|   1 |   1 | 0.5 |   A |\n|   1 |   3 | 1.5 |   C |\n|   1 |   5 | 1.0 |   B |\n|   1 |   7 | 0.5 |   A |\n|   1 |   9 | 1.5 |   C |\n, Group: 2 [4 4]:\n\n| :V1 | :V2 | :V3 | :V4 |\n|----:|----:|----:|-----|\n|   2 |   2 | 1.0 |   B |\n|   2 |   4 | 0.5 |   A |\n|   2 |   6 | 1.5 |   C |\n|   2 |   8 | 1.0 |   B |\n]}\n\nGrouped dataset as map\n\n(keys (tc/group-by DS :V1 {:result-type :as-map}))\n\n\n(1 2)\n\n\n(vals (tc/group-by DS :V1 {:result-type :as-map}))\n\n\n…\n\nGroup dataset as map of indexes (row ids)\n\n(tc/group-by DS :V1 {:result-type :as-indexes})\n\n\n{1 [0 2 4 6 8], 2 [1 3 5 7]}\n\nGrouped datasets are printed as follows by default.\n\n(tc/group-by DS :V1)\n\n\n…\n\nTo get groups as sequence or a map can be done from grouped dataset using groups->seq and groups->map functions.\nGroups as seq can be obtained by just accessing :data column.\nI will use temporary dataset here.\n\n(deftest groups-as-seq-1-test\n  (let [ds (-> {\"a\" [1 1 2 2]\n                \"b\" [\"a\" \"b\" \"c\" \"d\"]}\n               (tc/dataset)\n               (is-> #(-> % tc/row-count (= 4)))\n               (tc/group-by \"a\")\n               (is-> #(-> % tc/row-count (= 2))))]\n    (-> (seq (ds :data)) ; seq is not necessary but Markdown treats `:data` as command here\n        (is-> #(-> % count (= 2))))))\n\n\n…\n\n\n(deftest groups-as-seq-2-test\n  (-> {\"a\" [1 1 2 2]\n       \"b\" [\"a\" \"b\" \"c\" \"d\"]}\n      (tc/dataset)\n      (tc/group-by \"a\")\n      (tc/groups->seq)\n      (is-> #(-> % count (= 2)))))\n\n\n…\n\nGroups as map\n\n(deftest groups-as-map-test\n  (-> {\"a\" [1 1 2 2]\n       \"b\" [\"a\" \"b\" \"c\" \"d\"]}\n      (tc/dataset)\n      (tc/group-by \"a\")\n      (tc/groups->map)\n      (is-> #(-> % count (= 2)))\n      (is-> #(-> % keys (= [1 2])))))\n\n\n…\n\nGrouping by more than one column. You can see that group names are maps. When ungrouping is done these maps are used to restore column names.\n\n(tc/group-by DS [:V1 :V3] {:result-type :as-seq})\n\n\n…\n\nGrouping can be done by providing just row indexes. This way you can assign the same row to more than one group.\n\n(tc/group-by DS {\"group-a\" [1 2 1 2]\n                 \"group-b\" [5 5 5 1]} {:result-type :as-seq})\n\n\n…\n\nYou can group by a result of grouping function which gets row as map and should return group name. When map is used as a group name, ungrouping restore original column names.\n\n(tc/group-by DS (fn [row] (* (:V1 row)\n                             (:V3 row))) {:result-type :as-seq})\n\n\n…\n\nYou can use any predicate on column to split dataset into two groups.\n\n(tc/group-by DS (comp #(< % 1.0) :V3) {:result-type :as-seq})\n\n\n…\n\njuxt is also helpful\n\n(tc/group-by DS (juxt :V1 :V3) {:result-type :as-seq})\n\n\n…\n\ntech.ml.dataset provides an option to limit columns which are passed to grouping functions. It’s done for performance purposes.\n\n(tc/group-by DS identity {:result-type :as-seq\n                          :select-keys [:V1]})\n\n\n…\n\n\n\n4.2.1.2 Ungrouping\nUngrouping simply concats all the groups into the dataset. Following options are possible * :order? - order groups according to the group name ascending order. Default: false * :add-group-as-column - should group name become a column? If yes column is created with provided name (or :$group-name if argument is true). Default: nil. * :add-group-id-as-column - should group id become a column? If yes column is created with provided name (or :$group-id if argument is true). Default: nil. * :dataset-name - to name resulting dataset. Default: nil (_unnamed) If group name is a map, it will be splitted into separate columns. Be sure that groups (subdatasets) doesn’t contain the same columns already. If group name is a vector, it will be splitted into separate columns. If you want to name them, set vector of target column names as :add-group-as-column argument. After ungrouping, order of the rows is kept within the groups but groups are ordered according to the internal storage. Grouping and ungrouping.\n\n(-> DS\n    (tc/group-by :V3)\n    (tc/ungroup))\n\n\n…\n\nGroups sorted by group name and named.\n\n(-> DS\n    (tc/group-by :V3)\n    (tc/ungroup {:order? true\n                 :dataset-name \"Ordered by V3\"}))\n\n\n…\n\nGroups sorted descending by group name and named.\n\n(-> DS\n    (tc/group-by :V3)\n    (tc/ungroup {:order? :desc\n                 :dataset-name \"Ordered by V3 descending\"}))\n\n\n…\n\nLet’s add group name and id as additional columns\n\n(-> DS\n    (tc/group-by (comp #(< % 4) :V2))\n    (tc/ungroup {:add-group-as-column true\n                 :add-group-id-as-column true}))\n\n\n…\n\nLet’s assign different column names\n\n(-> DS\n    (tc/group-by (comp #(< % 4) :V2))\n    (tc/ungroup {:add-group-as-column \"Is V2 less than 4?\"\n                 :add-group-id-as-column \"group id\"}))\n\n\n…\n\nWe can add group names without separation\n\n(-> DS\n    (tc/group-by (fn [row] {\"V1 and V3 multiplied\" (* (:V1 row)\n                                                      (:V3 row))\n                            \"V4 as lowercase\" (clojure.string/lower-case (:V4 row))}))\n    (tc/ungroup {:add-group-as-column \"just map\"\n                 :separate? false}))\n\n\n…\n\nThe same applies to group names as sequences\n\n(-> DS\n    (tc/group-by (juxt :V1 :V3))\n    (tc/ungroup {:add-group-as-column \"abc\"}))\n\n\n…\n\nLet’s provide column names\n\n(-> DS\n    (tc/group-by (juxt :V1 :V3))\n    (tc/ungroup {:add-group-as-column [\"v1\" \"v3\"]}))\n\n\n…\n\nAlso we can supress separation\n\n(-> DS\n    (tc/group-by (juxt :V1 :V3))\n    (tc/ungroup {:separate? false\n                 :add-group-as-column true}))\n\n\n…\n\n=> _unnamed [9 5]:\n\n\n4.2.1.3 Other functions\nTo check if dataset is grouped or not just use grouped? function.\n\n(tc/grouped? DS)\n\n\nnil\n\n\n(tc/grouped? (tc/group-by DS :V1))\n\n\ntrue\n\nIf you want to remove grouping annotation (to make all the functions work as with regular dataset) you can use unmark-group or as-regular-dataset (alias) functions.\nIt can be important when you want to remove some groups (rows) from grouped dataset using drop-rows or something like that.\n\n(-> DS\n    (tc/group-by :V1)\n    (tc/as-regular-dataset)\n    (tc/grouped?))\n\n\nnil\n\nYou can also operate on grouped dataset as a regular one in case you want to access its columns using without-grouping-> threading macro.\n\n(-> DS\n    (tc/group-by [:V4 :V1])\n    (tc/without-grouping->\n     (tc/order-by (comp (juxt :V4 :V1) :name))))\n\n\n…\n\nThis is considered internal.\nIf you want to implement your own mapping function on grouped dataset you can call process-group-data and pass function operating on datasets. Result should be a dataset to have ungrouping working.\n\n(-> DS\n    (tc/group-by :V1)\n    (tc/process-group-data #(str \"Shape: \" (vector (tc/row-count %) (tc/column-count %))))\n    (tc/as-regular-dataset))\n\n\n…\n\n\n\n\n\nsource: projects/main/notebooks/scicloj/scrapbook/tests.clj"
  },
  {
    "objectID": "copies_of_projects/hdf/docs/scicloj/scrapbook/hdf_quarto.html",
    "href": "copies_of_projects/hdf/docs/scicloj/scrapbook/hdf_quarto.html",
    "title": "5  Processing HDF files",
    "section": "",
    "text": "source: projects/hdf/notebooks/scicloj/scrapbook/hdf.clj\n\n\n\n\n\n(ns scicloj.scrapbook.hdf\n  (:require [babashka.fs :as fs]\n            [tech.v3.tensor :as tensor]\n            [clojure.java.io :as io]\n            [clojure.string :as string]\n            [scicloj.noj.v1.vis.image :as vis.image]\n            [tech.v3.datatype.functional :as fun])\n  (:import io.jhdf.HdfFile\n           java.io.File))\n\n\n(set! *warn-on-reflection* true)\n\n\ntrue\n\n\n(defn hdf5->tensors [path]\n  (let [file ^File (io/file path)\n        hdf-file ^HdfFile (HdfFile. file)\n        children ^java.util.Map (.getChildren hdf-file)]\n    (->> children\n         keys\n         (mapv (fn [key]\n                 (let [child ^io.jhdf.dataset.ContiguousDatasetImpl (.get children key)\n                       knew (keyword (first (string/split key\n                                                          #\" \")))]\n                   {:key key\n                    :data (-> child\n                              .getData\n                              tensor/->tensor)}))))))\n\n\n(def tensors\n  (hdf5->tensors \"data/test.h5\"))\n\n\n(count tensors)\n\n\n20\n\n\n(take 3 tensors)\n\n\n({:key \"0\", :data #tech.v3.tensor&lt;int32&gt;[600 800]\n[[112 110 111 ... 114 118 124]\n [105 112 106 ... 115 120 119]\n [107 109 108 ... 117 123 115]\n ...\n [132 138 134 ... 109 107 109]\n [130 129 129 ... 115 111 103]\n [134 135 134 ... 110 111 110]]}\n {:key \"1\", :data #tech.v3.tensor&lt;int32&gt;[600 800]\n[[124 120 121 ... 117 121 124]\n [118 123 117 ... 118 122 121]\n [120 123 117 ... 119 123 118]\n ...\n [133 139 136 ... 111 106 108]\n [133 132 131 ... 116 111 103]\n [136 137 135 ... 114 111 108]]}\n {:key \"10\", :data #tech.v3.tensor&lt;int32&gt;[600 800]\n[[125 120 120 ... 116 121 127]\n [116 122 116 ... 117 121 119]\n [120 121 115 ... 120 123 118]\n ...\n [132 139 133 ... 112 107 108]\n [135 132 132 ... 115 112 104]\n [134 135 135 ... 114 112 108]]})\n\n\n(->> tensors\n     (take 3)\n     (mapcat (fn [row]\n               [row\n                (-> row\n                    :data\n                    (fun/* 200)\n                    (vis.image/tensor->image\n                     :ushort-gray))])))\n\n\n…\n\n\n\n\n\nsource: projects/hdf/notebooks/scicloj/scrapbook/hdf.clj"
  }
]